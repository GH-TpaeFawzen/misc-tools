#!/bin/sh

######################################################################
#
# FSED - flexible sed (looks like the fgrep)
#
# Usage  : fsed <pattern_str> <substitute_str> <file> [file...]
#
# * fsed is more flexible substituter than the sed command. This
#   ignores all of the functions which every meta-character of regular
#   expression has, so that you can very easily substitute strings
#   include various meta-characters, e.g. ^, $, \, /, &, and so on.
#
# Written by Shell-Shoccar Japan (@shellshoccarjpn) on 2017-03-04
#
# This is a public-domain software. It means that all of the people
# can use this with no restrictions at all. By the way, I am fed up
# the side effects which are brought about by the major licenses.
#
######################################################################


######################################################################
# Initial Configuration
######################################################################

# === Initialize shell environment ===================================
set -u
umask 0022
export LC_ALL=C
export PATH="$(command -p getconf PATH)${PATH:+:}${PATH:-}"

# === Define the functions for printing usage and error message ======
print_usage_and_exit () {
  cat <<-USAGE 1>&2
	Usage   : ${0##*/} <pattern_str> <substitute_str> <file> [file...]
	Version : 2017-03-04 15:11:01 JST
	          (POSIX Bourne Shell/POSIX commands)
	USAGE
  exit 1
}
warning() {
  ${1+:} false && echo "${0##*/}: $1" 1>&2
}


######################################################################
# Argument Parsing
######################################################################

# === Parse arguments (except files) =================================
case $# in [01]) print_usage_and_exit;; esac
[ $(printf '%s\n' "$1" | wc -l | awk '{print $1}') -eq 1 ] || {
  echo "${0##*/}: It is impossible to contain <0x0A> in <pattern_str>" 1>&2
  exit 1
}
pat=$(printf '%s\n' "$1"          |
      sed 's/\([].\*/[]\)/\\\1/g' |
      sed '1s/^^/\\^/'            |
      sed '$s/$$/\\$/'            )
sub=$(printf '%s\n' "$2"       |
      sed 's/\([\&/]\)/\\\1/g' |
      sed 's/$/\\/'            |
      sed '$s/\\$//'           )
shift 2


######################################################################
# Main Routine
######################################################################

case $# in 0) set -- -;; esac
use_stdin=0
for file0 in "$@"; do                                            #
  file=$file0                                                    #
  if   [ "_$file" = '_-' ]                               ; then  #
    cat                                                          #
  elif [ -f "$file" ] || [ -c "$file" ] || [ -p "$file" ]; then  #
    case "$file" in /*|./*|../*) :;; *) File="./$file";; esac    #
    cat "$file"                                                  #
  else                                                           #
    warning 'Cannot open as a file: '"$file0"                    #
    ret=1                                                        #
    continue                                                     #
  fi                                                             #
  ret=$?                                                         #
  [ $ret -eq 0 ] || { warning 'Failed to fsed: '"$file0"; }      #
done                                                             |
(cat; echo '')                                                   |
sed "s/$pat/$sub/g"                                              |
awk 'BEGIN{ORS=""; OFS="";                                       #
           getline line;                                         #
           print line;                                           #
           dlm=sprintf("\n");                                    #
           while (getline line) {print dlm,line;} }'