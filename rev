#!/bin/sh

######################################################################
#
# REV - A POSIX Compatible Implementation Of The "rev" Command
#       Also Works On Just A POSIX Environment
#
# USAGE: rev [--by-myself] [filename ...]
#
#        --by-myself .... (write as the 1st argument when use)
#                         Not use the "built-in" rev command and always
#                         do seq by myself but it is inferior to the
#                         built-in in performance
#                         with leading zeros.
#
# Written by Shell-Shoccar Japan (@shellshoccarjpn) on 2017-03-05
#
# This is a public-domain software (CC0). It means that all of the
# people can use this for any purposes with no restrictions at all.
# By the way, We are fed up with the side effects which are brought
# about by the major licenses.
#
######################################################################


######################################################################
# Initial Configuration
######################################################################

# === Initialize shell environment ===================================
set -u
umask 0022
export LC_ALL=C
export PATH="$(command -p getconf PATH)${PATH:+:}${PATH:-}"

# === Define the functions for printing usage and error message ======
print_usage_and_exit () {
  cat <<-USAGE 1>&2
	Usage   : ${0##*/} [--by-myself] [filename ...]
	Arg&Opts: Almost compatible with the original rev command
	          But --by-myself is the only original option, it prevent
	          from use the built-in same name command even if available
	Version : 2017-03-05 04:49:02 JST
	          (POSIX Bourne Shell/POSIX commands)
	            * Although the bult-in rev produces better performance
	              than the POSIX commands set
	USAGE
  exit 1
}
error_exit() {
  ${2+:} false && echo "${0##*/}: $2" 1>&2
  exit $1
}

# === Exec the built-in rev command if OK and exists =================
by_myself=0
case "${1:-}" in 
  '--by-myself')
     shift; by_myself=1
     ;;
  *) case "$(d=${0%/*}/;[ "_$d" = "_$0/" ]||cd "$d";echo "$(pwd)/${0##*/}")" in
       "$(command -v rev 2>/dev/null)") by_myself=1;;
     esac
     ;;
esac
case $by_myself in 0) exec rev "$@"; exit 1;; esac


######################################################################
# Argument Parsing and Reversing
######################################################################

# === print help if requested ========================================
case "${1:-}" in -h|-v|--help|--version) print_usage_and_exit;; esac

# === do it ==========================================================
case $# in 0) set -- -;; esac
use_stdin=0
for arg in "$@"; do
  file=$arg
  case "$file" in -|/*|./*|../*) :;; *) file="./$file";; esac
  case "$file" in 
    -|/dev/stdin|/dev/fd/0|/proc/self/fd/0)
       case $use_stdin in
         [!0]*) error_exit 1 'stdin can be used only once in the arguments';;
       esac
       use_stdin=1
       ;;
    *) if ([ ! -f "$file" ] && [ ! -c "$file" ] && [ ! -p "$file" ]) ||
          [ ! -r "$file" ]                                             ; then
         error_exit 1 "Cannot open the file \"$arg\""
       fi
       ;;
  esac
  awk 'BEGIN { ORS="";                                               }
       { for(i=length($0);i>0;i--){print substr($0,i,1);} print "\n";}' "$file"
  ret=$?
  case $ret in [!0]*) error_exit $ret 'Error happend while reversing';; esac
done


######################################################################
# Finish
######################################################################

exit 0